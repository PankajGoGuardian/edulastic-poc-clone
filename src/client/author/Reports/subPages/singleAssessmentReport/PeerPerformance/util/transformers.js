import { startCase } from 'lodash'
import { reportUtils } from '@edulastic/constants'

const { getHSLFromRange1 } = reportUtils.common

const _idToLabel = {
  schoolId: 'schoolName',
  teacherId: 'teacherName',
  groupId: 'groupName',
  // group: 'groupName', // compareByLabel is generated by groupId for student groups as well
  race: 'race',
  gender: 'gender',
  frlStatus: 'frlStatus',
  ellStatus: 'ellStatus',
  iepStatus: 'iepStatus',
  hispanicEthnicity: 'hispanicEthnicity',
}
export const idToLabel = (id) => _idToLabel[id] || id

const _idToName = {
  school: 'School',
  class: 'Class',
  group: 'Student Group',
  teacher: 'Teacher',
  race: 'Race',
  gender: 'Gender',
  frlStatus: 'FRL Status',
  ellStatus: 'ELL Status',
  iepStatus: 'IEP Status',
  hispanicEthnicity: 'Hispanic Ethnicity',
}
export const idToName = (id) => _idToName[id] || startCase(id)

export const analyseByToName = {
  'score(%)': 'Score (%)',
  rawScore: 'Raw Score',
  aboveBelowStandard: 'Above/Below Standard',
  proficiencyBand: 'Proficiency Band',
}

export const analyseByOptions = {
  scorePerc: 'score(%)',
  rawScore: 'rawScore',
  aboveBelowStandard: 'aboveBelowStandard',
  proficiencyBand: 'proficiencyBand',
}

export const compareByKeyMaps = [
  { key: 'school', title: 'School' },
  { key: 'teacher', title: 'Teacher' },
  { key: 'class', title: 'Class' },
  { key: 'group', title: 'Student Group' },
  { key: 'race', title: 'Race' },
  { key: 'gender', title: 'Gender' },
  { key: 'frlStatus', title: 'FRL Status' },
  { key: 'ellStatus', title: 'ELL Status' },
  { key: 'iepStatus', title: 'IEP Status' },
  { key: 'hispanicEthnicity', title: 'Hispanic Ethnicity' },
]
const standardConst = {
  above: 1,
  below: 0,
}

export const sortKeyMaps = {
  DIMENSION: 'dimension',
  DIM_SCORE_PERC: 'scorePerc',
  ABOVE_STANDARD: 'aboveStandard',
}
export const sortOrderMap = {
  ascend: 'asc',
  descend: 'desc',
}
const calculateStudentsInPerformanceBands = (
  performanceBandDetails,
  performanceBand,
  totalStudents
) => {
  if (!performanceBandDetails) {
    return {}
  }
  const studentsInPerformanceBands = performanceBand.reduce(
    (acc, { name }) => ({ ...acc, [name]: 0, [`${name}Percentage`]: 0 }),
    {}
  )

  performanceBand.forEach(({ threshold, name, aboveStandard }) => {
    const band = performanceBandDetails.find((b) => b.threshold === threshold)
    if (band) {
      studentsInPerformanceBands[name] += band.studentsInBand
      const perc = Number((band.studentsInBand * 100) / totalStudents).toFixed(
        0
      )
      studentsInPerformanceBands[`${name}Percentage`] =
        aboveStandard === standardConst.above ? perc : -perc
    }
  })

  return studentsInPerformanceBands
}
function transformByProficiencyBand(data, bandInfo) {
  const transformedData = data.map((item) => {
    const bandDetails = calculateStudentsInPerformanceBands(
      item?.performanceBandDetails,
      bandInfo?.performanceBand,
      item?.submittedStudents
    )
    return {
      ...item,
      dimensionId: item.dimension._id,
      ...bandDetails,
    }
  })
  return transformedData
}
function transformByAboveBelowStandard(data) {
  const transformedData = data.map((item) => {
    const aboveStandardPercentage = Number(
      ((100 * item.aboveStandard) / item.totalStudents).toFixed(0)
    )
    const belowStandardPercentage = aboveStandardPercentage - 100
    return {
      ...item,
      dimensionId: item.dimension._id,
      aboveStandardPercentage,
      belowStandardPercentage,
      fill_0: getHSLFromRange1(100),
      fill_1: getHSLFromRange1(0),
    }
  })
  return transformedData
}

function transformByRawScore(data) {
  const transformedData = data.map((item) => {
    const maxScore = (item.dimensionMaxScore / item.submittedStudents)?.toFixed(
      2
    )
    return {
      ...item,
      maxScore,
      dimensionId: item.dimension._id,
      correct: item.dimensionAvg?.toFixed(2),
      incorrect: (maxScore - item.dimensionAvg)?.toFixed(2),
      fill: getHSLFromRange1((100 * item.dimensionAvg) / maxScore),
      dFill: getHSLFromRange1((item.districtAvg * 100) / maxScore),
    }
  })
  return transformedData
}

function transformScorePerc(data) {
  const transformedData = data.map((item) => {
    return {
      ...item,
      dimensionId: item.dimension._id,
      correct: item.dimensionAvg?.toFixed(0),
      incorrect: (100 - item.dimensionAvg).toFixed(0),
      fill: getHSLFromRange1(item.dimensionAvg),
      dFill: getHSLFromRange1(item.districtAvg),
    }
  })
  return transformedData
}
export const transformData = (filter, bandInfo, data) => {
  if (data?.length) {
    switch (filter.analyseBy) {
      case analyseByOptions.proficiencyBand:
        return transformByProficiencyBand(data, bandInfo)
      case analyseByOptions.aboveBelowStandard:
        return transformByAboveBelowStandard(data)
      case analyseByOptions.rawScore:
        return transformByRawScore(data)
      case analyseByOptions.scorePerc:
        return transformScorePerc(data)
      default:
        return data
    }
  } else return []
}
const filterValue = (arr) => {
  const blackList = ['', 'null', 'undefined']
  return arr.filter((item) => !blackList.includes(item))
}
export const transformExtAttributes = (extAttributes) => {
  if (extAttributes?.length) {
    const transferredData = {}
    extAttributes.forEach((item) => {
      const value = filterValue(item.value)
      if (value?.length) transferredData[item.name] = value
    })
    return transferredData
  }
  return {}
}

export const transformExtAttributeFilters = (filterData) => {
  const _extDemogaphicFilters = filterData.map((item) => JSON.parse(item))
  const result = {}
  _extDemogaphicFilters.forEach((item) => {
    const [key, value] = Object.entries(item)[0]
    if (!result[key]) {
      result[key] = []
    }
    result[key].push(value)
  })
  return JSON.stringify(result)
}
export const getFormattedName = (item) => {
  return item
    ? item
        .split('_')
        .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ')
    : ''
}
