import {
  groupBy,
  minBy,
  maxBy,
  cloneDeep,
  countBy,
  uniq,
  isEmpty,
  orderBy,
  startCase,
} from 'lodash'

import { testActivityStatus, reportUtils } from '@edulastic/constants'

const { getHSLFromRange1, DemographicCompareByOptions } = reportUtils.common

const { transformMetricForStudentGroups } = reportUtils.singleAssessmentReport

const _idToLabel = {
  schoolId: 'schoolName',
  teacherId: 'teacherName',
  groupId: 'groupName',
  // group: 'groupName', // compareByLabel is generated by groupId for student groups as well
  race: 'race',
  gender: 'gender',
  frlStatus: 'frlStatus',
  ellStatus: 'ellStatus',
  iepStatus: 'iepStatus',
  hispanicEthnicity: 'hispanicEthnicity',
}
export const idToLabel = (id) => _idToLabel[id] || id

const _idToName = {
  schoolId: 'School',
  groupId: 'Class',
  group: 'Student Group',
  teacherId: 'Teacher',
  race: 'Race',
  gender: 'Gender',
  frlStatus: 'FRL Status',
  ellStatus: 'ELL Status',
  iepStatus: 'IEP Status',
  hispanicEthnicity: 'Hispanic Ethnicity',
}
export const idToName = (id) => _idToName[id] || startCase(id)

export const analyseByToName = {
  'score(%)': 'Score (%)',
  rawScore: 'Raw Score',
  aboveBelowStandard: 'Above/Below Standard',
  proficiencyBand: 'Proficiency Band',
}

export const parseAndNormalizeExtAttributes = (extAttributesStr) => {
  const blackList = ['', 'null', 'undefined']
  const extAttributes = JSON.parse(extAttributesStr || '{}')
  Object.keys(extAttributes).forEach((k) => {
    const v = `${extAttributes[k]}`.toLowerCase()
    if (blackList.includes(v)) {
      extAttributes[k] = undefined
    }
  })
  return extAttributes
}

const filterMetricInfoByExtDemographicFilters = (metrics, filters) => {
  if (isEmpty(filters)) {
    return metrics
  }
  const transformedFilter = {}
  filters.forEach((filter) => {
    const parsedFilterValue = JSON.parse(filter)
    const key = Object.keys(parsedFilterValue)[0]
    const value = parsedFilterValue[key]
    if (Object.prototype.hasOwnProperty.call(transformedFilter, key)) {
      transformedFilter[key].push(value)
    } else {
      transformedFilter[key] = [value]
    }
  })
  return metrics.filter((metric) => {
    let isFilterValuePresent = true
    for (const key of Object.keys(transformedFilter)) {
      if (!isFilterValuePresent) {
        break
      }
      isFilterValuePresent =
        isFilterValuePresent &&
        transformedFilter[key].includes(metric.extAttributes[key])
    }
    return isFilterValuePresent
  })
}

const filterData = (data, filter) => {
  const filteredData = data.filter((item) => {
    if (
      (item.gender?.toLowerCase() === filter.gender.toLowerCase() ||
        filter.gender === 'all') &&
      (item.frlStatus?.toLowerCase() === filter.frlStatus.toLowerCase() ||
        filter.frlStatus === 'all') &&
      (item.ellStatus?.toLowerCase() === filter.ellStatus.toLowerCase() ||
        filter.ellStatus === 'all') &&
      (item.iepStatus?.toLowerCase() === filter.iepStatus.toLowerCase() ||
        filter.iepStatus === 'all') &&
      (item.race?.toLowerCase() === filter.race.toLowerCase() ||
        filter.race === 'all') &&
      (item.hispanicEthnicity?.toLowerCase() ===
        filter.hispanicEthnicity.toLowerCase() ||
        filter.hispanicEthnicity === 'all')
    ) {
      return true
    }
    return false
  })
  return filteredData
}

const analyseByScorePercent = (rawData, groupedData, compareBy) => {
  const arr = Object.keys(groupedData).map((data) => {
    let item = groupedData[data].reduce(
      (total, currentValue) => {
        const { maxScore = 0, totalScore = 0, progressStatus } = currentValue
        return {
          // progressStatus = 2 is for absent student, needs to be excluded
          totalMaxScore:
            total.totalMaxScore + (progressStatus === 2 ? 0 : maxScore),
          totalTotalScore: total.totalTotalScore + totalScore,
        }
      },
      { totalMaxScore: 0, totalTotalScore: 0 }
    )

    const avgStudentScorePercentUnrounded =
      (item.totalTotalScore / item.totalMaxScore) * 100 || 0
    const avgStudentScorePercent = Math.round(avgStudentScorePercentUnrounded)
    const { teacherName, groupName: className } = groupedData[data][0]
    const statusCounts = countBy(groupedData[data], (o) => o.progressStatus)
    let absent = statusCounts[testActivityStatus.ABSENT] || 0
    absent += statusCounts[testActivityStatus.UN_ASSIGNED] || 0
    absent += statusCounts[testActivityStatus.UN_ENROLLED] || 0
    const schoolName = uniq(
      groupedData[data]
        .map((o) => (isEmpty(o.schoolName) ? ' - ' : o.schoolName))
        .filter((txt) => txt)
    ).join(', ')

    item = {
      ...item,
      avgStudentScorePercentUnrounded,
      avgStudentScorePercent,
      correct: avgStudentScorePercent,
      incorrect: Math.round(100 - avgStudentScorePercent),
      districtAvg: Math.round(rawData.districtAvgPerf),
      absent,
      graded: statusCounts[testActivityStatus.SUBMITTED] || 0,
      schoolName,
      teacherName,
      className,
      [compareBy]: data,
      compareBy,
      compareBylabel: groupedData[data][0]?.[idToLabel(compareBy)] || '-',
      fill: getHSLFromRange1(avgStudentScorePercent),
      dFill: getHSLFromRange1(rawData.districtAvgPerf),
    }
    return item
  })
  return arr
}

const analyseByRawScore = (rawData, groupedData, compareBy) => {
  const arr = Object.keys(groupedData).map((data) => {
    let item = groupedData[data].reduce(
      (total, currentValue) => {
        const { maxScore = 0, totalScore = 0, progressStatus } = currentValue
        return {
          // progressStatus = 2 is for absent student, needs to be excluded
          totalMaxScore:
            total.totalMaxScore + (progressStatus === 2 ? 0 : maxScore),
          totalTotalScore: total.totalTotalScore + totalScore,
        }
      },
      { totalMaxScore: 0, totalTotalScore: 0 }
    )

    const statusCounts = countBy(groupedData[data], (o) => o.progressStatus)
    const avgStudentScoreUnrounded =
      item.totalTotalScore / (statusCounts[1] || 1) || 0
    const avgStudentScore = Number(avgStudentScoreUnrounded.toFixed(2))
    // TODO prefer BE fix: https://github.com/snapwiz/edu-api/pull/8306
    // Following is only immediate fix
    const itemWithMaxScore =
      maxBy(groupedData[data], 'maxScore') || groupedData[data][0]
    const { teacherName, groupName: className } = itemWithMaxScore
    const maxScore = Math.max(itemWithMaxScore.maxScore, avgStudentScore) || 1
    let absent = statusCounts[testActivityStatus.ABSENT] || 0
    absent += statusCounts[testActivityStatus.UN_ASSIGNED] || 0
    absent += statusCounts[testActivityStatus.UN_ENROLLED] || 0
    const schoolName = uniq(
      groupedData[data]
        .map((o) => (isEmpty(o.schoolName) ? ' - ' : o.schoolName))
        .filter((txt) => txt)
    ).join(', ')

    item = {
      ...item,
      maxScore,
      avgStudentScoreUnrounded,
      avgStudentScore,
      correct: avgStudentScore,
      incorrect: Number((maxScore - avgStudentScore).toFixed(2)),
      districtAvg: Number(rawData.districtAvg.toFixed(2)),
      absent,
      graded: statusCounts[testActivityStatus.SUBMITTED] || 0,
      schoolName,
      teacherName,
      className,
      [compareBy]: data,
      compareBy,
      compareBylabel: itemWithMaxScore?.[idToLabel(compareBy)] || '-',
      fill: getHSLFromRange1((avgStudentScore / maxScore) * 100),
      dFill: getHSLFromRange1(rawData.districtAvgPerf),
    }
    return item
  })
  return arr
}

const analyseByAboveBelowStandard = (rawData, groupedData, compareBy) => {
  const { threshold } = minBy(rawData.bandInfo, (o) => {
    if (o.aboveStandard === 1) {
      return o.threshold
    }
    return Infinity
  })

  const getStandard = (item) => {
    if ((item.totalScore / item.maxScore) * 100 >= threshold) {
      return 'aboveStandard'
    }
    return 'belowStandard'
  }

  const arr = Object.keys(groupedData).map((data) => {
    let item = groupedData[data].reduce(
      (total, currentValue) => {
        const standard = getStandard(currentValue)
        return {
          ...total,
          [standard]:
            total[standard] + (currentValue.progressStatus === 2 ? 0 : 1),
          total: total.total + (currentValue.progressStatus === 2 ? 0 : 1),
        }
      },
      { belowStandard: 0, aboveStandard: 0, total: 0 }
    )

    const belowStandardPercentage = -Math.round(
      (item.belowStandard / (item.total || 1)) * 100
    )
    const aboveStandardPercentage = Math.round(
      (item.aboveStandard / (item.total || 1)) * 100
    )

    const { teacherName, groupName: className } = groupedData[data][0]
    const statusCounts = countBy(groupedData[data], (o) => o.progressStatus)
    let absent = statusCounts[testActivityStatus.ABSENT] || 0
    absent += statusCounts[testActivityStatus.UN_ASSIGNED] || 0
    absent += statusCounts[testActivityStatus.UN_ENROLLED] || 0
    const schoolName = uniq(
      groupedData[data]
        .map((o) => (isEmpty(o.schoolName) ? ' - ' : o.schoolName))
        .filter((txt) => txt)
    ).join(', ')

    item = {
      ...item,
      aboveStandardPercentage,
      belowStandardPercentage,
      districtAvg: Number(rawData.districtAvg.toFixed(2)),
      absent,
      graded: statusCounts[testActivityStatus.SUBMITTED] || 0,
      schoolName,
      teacherName,
      className,
      [compareBy]: data,
      compareBy,
      compareBylabel: groupedData[data][0]?.[idToLabel(compareBy)] || '-',
      fill_0: getHSLFromRange1(100),
      fill_1: getHSLFromRange1(0),
    }

    return item
  })
  return arr
}

const analyseByProficiencyBand = (rawData, groupedData, compareBy) => {
  const bandInfo = cloneDeep(rawData.bandInfo)
  const proficiencies = {}
  const proficienciesDetail = {}
  for (const o of rawData.bandInfo) {
    proficiencies[o.name] = 0
    proficienciesDetail[o.name] = o
  }

  bandInfo.sort((a, b) => b.threshold - a.threshold)

  const bandInfoAsc = [...bandInfo]
  bandInfoAsc.reverse()

  const getProficiency = (item) => {
    for (const obj of bandInfo) {
      if ((item.totalScore / item.maxScore) * 100 >= obj.threshold) {
        return obj.name
      }
    }
  }

  const arr = Object.keys(groupedData).map((data) => {
    let item = groupedData[data].reduce(
      (total, currentValue) => {
        const proficiency = getProficiency(currentValue)
        total[proficiency] += currentValue.progressStatus === 2 ? 0 : 1
        total.total += currentValue.progressStatus === 2 ? 0 : 1
        return {
          ...total,
        }
      },
      { ...proficiencies, total: 0 }
    )

    const proficiencyPercentages = {}

    bandInfoAsc.forEach((o, index) => {
      const prof = Math.round((item[o.name] / (item.total || 1)) * 100)
      const fill = Math.round((100 / (bandInfo.length - 1)) * index)
      if (proficienciesDetail[o.name].aboveStandard !== 1) {
        proficiencyPercentages[`${o.name}Percentage`] = -prof
      } else {
        proficiencyPercentages[`${o.name}Percentage`] = prof
      }
      proficiencyPercentages[`fill_${index}`] = getHSLFromRange1(fill)
    })

    const { teacherName, groupName: className } = groupedData[data][0]
    const statusCounts = countBy(groupedData[data], (o) => o.progressStatus)
    let absent = statusCounts[testActivityStatus.ABSENT] || 0
    absent += statusCounts[testActivityStatus.UN_ASSIGNED] || 0
    absent += statusCounts[testActivityStatus.UN_ENROLLED] || 0
    const schoolName = uniq(
      groupedData[data]
        .map((o) => (isEmpty(o.schoolName) ? ' - ' : o.schoolName))
        .filter((txt) => txt)
    ).join(', ')

    item = {
      ...item,
      ...proficiencyPercentages,
      districtAvg: Number(rawData.districtAvg.toFixed(2)),
      absent,
      graded: statusCounts[testActivityStatus.SUBMITTED] || 0,
      schoolName,
      teacherName,
      className,
      [compareBy]: data,
      compareBy,
      compareBylabel: groupedData[data][0]?.[idToLabel(compareBy)] || '-',
    }

    return item
  })
  return arr
}

export const parseData = (rawData, filter, extDemogaphicFilters) => {
  let compareBy = filter.compareBy
  let data = rawData.metricInfo || []
  if (DemographicCompareByOptions.includes(compareBy)) {
    data = orderBy(data, compareBy, ['asc'])
  }
  if (filter.compareBy === 'group') {
    data = transformMetricForStudentGroups(rawData.studentGroupInfo, data)
    compareBy = 'groupId'
  }
  const filteredDataByDdFilter = filterData(data, filter)
  const filteredDataByExtDemographicFilter = filterMetricInfoByExtDemographicFilters(
    filteredDataByDdFilter,
    extDemogaphicFilters
  )
  const groupedData = groupBy(filteredDataByExtDemographicFilter, compareBy)
  let output = []
  if (filter.analyseBy === 'score(%)') {
    output = analyseByScorePercent(rawData, groupedData, compareBy)
  } else if (filter.analyseBy === 'rawScore') {
    output = analyseByRawScore(rawData, groupedData, compareBy)
  } else if (filter.analyseBy === 'aboveBelowStandard') {
    output = analyseByAboveBelowStandard(rawData, groupedData, compareBy)
  } else if (filter.analyseBy === 'proficiencyBand') {
    output = analyseByProficiencyBand(rawData, groupedData, compareBy)
  }
  return output.sort((a, b) => a.compareBylabel.localeCompare(b.compareBylabel))
}

export const createExtDemographicGroupedData = (metrics, ddfilter) => {
  const extAttributesData = filterData(metrics, ddfilter).map(
    (metric) => metric.extAttributes
  )
  return extAttributesData.reduce((prev, curr) => {
    Object.keys(curr).forEach((key) => {
      if (!isEmpty(curr[key])) {
        if (Object.prototype.hasOwnProperty.call(prev, key)) {
          if (prev[key].indexOf(curr[key]) === -1) {
            prev[key].push(curr[key])
          }
        } else {
          prev[key] = [curr[key]]
        }
      }
    })
    return prev
  }, {})
}
